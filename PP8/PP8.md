# **并行程序设计与算法实验 8**

| 实验  | 最短路径并行实现       | 专业     | 计算机科学与技术 |
| ----- | ---------------------- | -------- | ---------------- |
| 学号  | 21311525               | 姓名     | 马梓培           |
| Email | mazp@mail2.sysu.edu.cn | 完成日期 | 2024/05/15       |

## 1. 实验要求

> **并行多源最短路径搜索**
>
> - 使用OpenMP/Pthreads/MPI中的任意一种
>
> - 可选用任意最短路径算法
>
> - 设置线程数量（1-16）
>
> - 根据运行时间，分析程序并行性能
>
>   •算法、并行框架、并行方式、数据（节点数量，平均度数）

## 2. 实验原理

借鉴自[oi-wiki](https://oi-wiki.org/graph/shortest-path/#floyd-算法)

### 2.1 Floyd 算法

是用来求任意两个结点之间的最短路的。

复杂度比较高，但是常数小，容易实现（只有三个 `for`）。

适用于任何图，不管有向无向，边权正负，但是最短路必须存在。（不能有个负环）

#### 2.1.1 实现

我们定义一个数组 $\mathrm{f}[\mathrm{k}][\mathrm{x}][\mathrm{y}]$, 表示只允许经过结点 1 到 $k$ （也就是说, 在子图 $V^{\prime}=1,2, \ldots, k$中的路径, 注意, $x$ 与 $y$ 不一定在这个子图中), 结点 $x$ 到结点 $y$ 的最短路长度。

很显然, $f[n][x][y]$ 就是结点 $x$ 到结点 $y$ 的最短路长度（因为 $V^{\prime}=1,2, \ldots, n$ 即为 $V$ 本身, 其表示的最短路径就是所求路径）。

接下来考虑如何求出 $f$ 数组的值。
$\mathrm{f}[0][\mathrm{x}][\mathrm{y}]: x$ 与 $y$ 的边权, 或者 0 , 或者 $+\infty(\mathrm{f}[0][\mathrm{x}][\mathrm{y}]$ 什么时候应该是 $+\infty ?$ 当 $x$ 与 $y$间有直接相连的边的时候, 为它们的边权; 当 $x=y$ 的时候为零, 因为到本身的距离为零; 当 $x$与 $y$ 没有直接相连的边的时候, 为 $+\infty)$ 。
$f[k][x][y]=\min (f[k-1][x][y], f[k-1][x][k]+f[k-1][k][y])(f[k-1][x][y]$, 为不经过 $k$点的最短路径, 而 $f[k-1][x][k]+f[k-1][k][y]$, 为经过了 $k$ 点的最短路)。

上面两行都显然是对的，所以说这个做法空间是 $O\left(N^3\right)$ ，我们需要依次增加问题规模（ $k$ 从 1 到 n) , 判断任意两点在当前问题规模下的最短路。

```c
for (k = 1; k <= n; k++) {
  for (x = 1; x <= n; x++) {
    for (y = 1; y <= n; y++) {
      f[k][x][y] = min(f[k - 1][x][y], f[k - 1][x][k] + f[k - 1][k][y]);
    }
  }
}
```

因为第一维对结果无影响，我们可以发现数组的第一维是可以省略的，于是可以直接改成`f[x][y] = min(f[x][y], f[x][k]+f[k][y])`.

```c
for (k = 1; k <= n; k++) {
  for (x = 1; x <= n; x++) {
    for (y = 1; y <= n; y++) {
      f[x][y] = min(f[x][y], f[x][k] + f[k][y]);
    }
  }
}
```

综上时间复杂度是 $O\left(N^3\right)$, 空间复杂度是 $O\left(N^2\right)$ 。

## 3. 实现代码

代码见附件或github.
